<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Chinese&nbsp;Morphological&nbsp;Analyzer(Chen): Document of the Chinese Morphological Analyzer(Chen)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Document of the Chinese Morphological Analyzer(Chen)</h1><h3>VernkinChen </h3><p><b>CMA</b> (Chinese Morphological Analyzer) is a platform-independent C++ library for Chinese word segmentation and POS tagging. And Chinese Morphological Analyzer(Chen) is using Maxent Model and Character-baed Segmentation to perform segmentation and POS tagging.</p>
<h2><a class="anchor" id="compilefile">
Compile the file</a></h2>
<p>Two approaches can be used to compile. For the final user, the second approach is recommended.</p>
<p>1. Use the cmake directly.</p>
<ol>
<li>
Using shell, go to the project root directory. </li>
<li>
Type ".cd build ". </li>
<li>
Under linux, type "cmake ../source"; Under windows, run in the msys, type "cmake -G "Unix Makefiles" ../source ". </li>
<li>
Finally Type ".make ". to compile all the source. </li>
</ol>
<p>2. Use a script build/build.sh to compile. The usage is:<br/>
 <b>./build.sh [ release | debug | profile | clean ] [ linux | win32 ]</b><br/>
</p>
<p>The parameters contains four building types (default is <b>release</b>) and two platforms (default is <b>linux</b>). For the building type, <b>debug</b> is compiled with debug information; <b>release</b> is for release purpose with optimized code; <b>profile</b> will add -pg which used by gprof; and <b>clean</b> will clean all temporal files. For the platform, <b>linux</b> represents linux platform while <b>win32</b> represents windows platform.</p>
<p>If the external program uses the library, simply add all the header files in the $include$ directory under the project root directory, and add the lib/libcmac.a into the library for static linking or lib/*.so for dynamic linking.</p>
<h2><a class="anchor" id="runtrainer">
Run the Trainer</a></h2>
<p>The dataset have to be trained by the Trainer. The Trainer is a executable file with name camctrainer under directory bin.</p>
<p>The SYNOPSIS for the trainer is: <br/>
 ./cmactrainer mateFile modelPath [encoding] [posDelimiter] <br/>
</p>
<p><br/>
The Description for the parameters: </p>
<ul>
<li>
mateFile is the material file, it should be in the form word1/pos1 word2/pos2 word3/pos3 ... </li>
<li>
modelPath is the directory to hold all the output files (include trained model files and dictionaries). </li>
<li>
encoding is the encoding of the mateFile, and gb18030 is the default encoding. Support utf8, gb18030, gb2312 and big5 now. </li>
<li>
posDelimiter is the delimiter between the word and the POS tag, like '/' and '_' and default is '/'. </li>
</ul>
<p>Take "/dir1/dir2 " as the cateFile, after the training. The following files are created (All under directory /dir1/dir2): </p>
<ol>
<li>
<b>pos.model</b> is the POS statistical model file. </li>
<li>
<b>pos.pos</b> is the all the POS gained from the training dataset. </li>
<li>
<b>sys.dic</b> is the dictionary (include words and POS tags) gained from the training dataset. This file is plain text and should be loaded as user dictionary. To convert it to the system dictionary, use Knowledge::encodeSystemDict(const char* txtFileName, const char* binFileName), then the binFileName can be loaded as the system dictioanry. </li>
<li>
<b>poc.model</b> is the POC statistical model file. </li>
</ol>
<p>All the files are required to run the program.<br/>
</p>
<h2><a class="anchor" id="rundemo">
Run the Demo</a></h2>
<p>After the training, you can run the demo to segment the file, The Demo is a executable file with name camcsegger under directory bin.</p>
<p>The SYNOPSIS for the trainer is: <br/>
 ./cmacsegger modelPath inFile outFile [encoding] [posDelimiter] <br/>
</p>
<p><br/>
The Description for the parameters: </p>
<ul>
<li>
modelPath is the directory contains all the tained models, dictionaries and configuration.  </li>
<li>
inFile the input file. </li>
<li>
outFile the output file. </li>
<li>
encoding is the encoding of the mateFile, and gb2312 is the default encoding. Support utf8, gb18030, gb2312 and big5. </li>
<li>
posDelimiter is the delimiter between the word and the pos tag, like '/' and '_' and default is '/'. </li>
</ul>
<p>The result with pos tagging can be found in the outFile.</p>
<h2><a class="anchor" id="useapi">
Use the API</a></h2>
<p>First of the all, add the lib/libcmac.a into the library path.</p>
<p><em>Step 1: Include the header files in directory "include"</em> </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;<a class="code" href="cma__factory_8h.html" title="CMA_Factory creates instances for Chinese morphological analysis.">cma_factory.h</a>&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="analyzer_8h.html" title="Analyzer executes the Chinese morphological analysis.">analyzer.h</a>&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="knowledge_8h.html" title="Knowledge manages the linguistic information for Chinese morphological analysis.">knowledge.h</a>&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="sentence_8h.html" title="Sentence saves the results of Chinese morphological analysis.">sentence.h</a>&quot;</span>
</pre></div><p><em>Step 2: Use the library name space</em> </p>
<div class="fragment"><pre class="fragment"><span class="keyword">using namespace </span>cma;
</pre></div><p><em>Step 3: Call the interface and handle the result</em></p>
<div class="fragment"><pre class="fragment"><span class="comment">// create instances</span>
CMA_Factory* factory = CMA_Factory::instance();
Analyzer* analyzer = factory-&gt;createAnalyzer();
Knowledge* knowledge = factory-&gt;createKnowledge();

<span class="comment">//It is suggested to set encoding after crate the Knowledge. Another supported encode type is big5.</span>
knowledge-&gt;setEncodeType(Knowledge::ENCODE_TYPE_GB2312);

<span class="comment">// Load all the model by specific modelPath and encoding</span>
knowledge-&gt;loadModel( <span class="stringliteral">&quot;gb18030&quot;</span>, <span class="stringliteral">&quot;...&quot;</span> ).

<span class="comment">// Load User Dictionaries and Stop Words if neccessary.</span>
knowledge-&gt;loadUserDict(<span class="stringliteral">&quot;...&quot;</span>);
knowledge-&gt;loadStopWordDict(<span class="stringliteral">&quot;...&quot;</span>);
 
<span class="comment">// (optional) if POS tagging is not needed, call the function below to turn off the analysis and </span>
<span class="comment">// output for POS tagging, so that large execution time could be saved when execute </span>
<span class="comment">// Analyzer::runWithSentence(), Analyzer::runWithString(), Analyzer::runWithStream().</span>
analyzer-&gt;setOption(Analyzer::OPTION_TYPE_POS_TAGGING, 0);

<span class="comment">// (optional) set the number of N-best results,</span>
<span class="comment">// if this function is not called, one-best analysis is performed defaultly on Analyzer::runWithSentence().</span>
analyzer-&gt;setOption(Analyzer::OPTION_TYPE_NBEST, 5);

<span class="comment">// set knowledge</span>
analyzer-&gt;setKnowledge(knowledge);

<span class="comment">// 1. analyze a paragraph</span>
<span class="keyword">const</span> <span class="keywordtype">char</span>* result = analyzer-&gt;runWithString(<span class="stringliteral">&quot;...&quot;</span>);
...

<span class="comment">// 2. analyze a file</span>
analyzer-&gt;runWithStream(<span class="stringliteral">&quot;...&quot;</span>, <span class="stringliteral">&quot;...&quot;</span>);

<span class="comment">// 3. split paragraphs into sentences</span>
<span class="keywordtype">string</span> line;
vector&lt;Sentence&gt; sentVec;
<span class="keywordflow">while</span>(getline(cin, line)) <span class="comment">// get paragraph string from standard input</span>
{
    sentVec.clear(); <span class="comment">// remove previous sentences</span>
    analyzer-&gt;splitSentence(line.c_str(), sentVec);
    <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0; i&lt;sentVec.size(); ++i)
    {
        analyzer-&gt;runWithSentence(sentVec[i]); <span class="comment">// analyze each sentence</span>
        ...
    }
}

<span class="comment">// destroy instances</span>
<span class="keyword">delete</span> knowledge;
<span class="keyword">delete</span> analyzer;
</pre></div> </div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Fri Nov 6 15:59:12 2009 for Chinese&nbsp;Morphological&nbsp;Analyzer(Chen) by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
